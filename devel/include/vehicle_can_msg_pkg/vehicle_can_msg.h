// Generated by gencpp from file vehicle_can_msg_pkg/vehicle_can_msg.msg
// DO NOT EDIT!


#ifndef VEHICLE_CAN_MSG_PKG_MESSAGE_VEHICLE_CAN_MSG_H
#define VEHICLE_CAN_MSG_PKG_MESSAGE_VEHICLE_CAN_MSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace vehicle_can_msg_pkg
{
template <class ContainerAllocator>
struct vehicle_can_msg_
{
  typedef vehicle_can_msg_<ContainerAllocator> Type;

  vehicle_can_msg_()
    : current_vehicle_speed(0)
    , Pure_Pursuit_angle__deg(0.0)
    , brake_pressure(0.0)
    , current_steer_angle__deg(0.0)
    , vehicle_target_speed__kph(0.0)
    , running_time_dead_reckoning_thread_running_time__ms(0.0)
    , running_time_pathfollow_thread_running_time__ms(0.0)
    , running_time_decision_thread_running_time__ms(0.0)
    , running_time_waypoint_publish_thread__ms(0.0)
    , running_time_local_path_planning_loop__ms(0.0)
    , running_time_global_path_planning_loop__ms(0.0)
    , dr_x(0.0)
    , dr_y(0.0)
    , dr_yaw_angle(0.0)
    , vehicle_yaw_rate(0.0)
    , dr_yaw_rate_integral_val(0.0)
    , elapsedTime(0.0)
    , target_accel(0.0)
    , target_brake_intensity(0.0)
    , target_steer_angle__deg(0.0)
    , h_acc(0.0)
    , v_acc(0.0)
    , yaw_acc(0.0)
    , imu_cali_yaw_angle(0.0)
    , imu_get_gnss_angle(0.0)
    , can_rw_thread_alive_count(0.0)
    , ccan_rw_thread_alive_count(0.0)
    , dn_lane_alive_count(0.0)
    , imu_vn300_alive_count(0.0)
    , lane_follow_enable_flag(0.0)
    , dr_check_flag(0.0)
    , avc_check_flag(0.0)
    , gnss_check_flag(0.0)
    , imu_yaw_angle_flag(0.0)
    , path_follow_check_flag(0.0)
    , ros_publisher_check_flag(0.0)
    , lateral_error(0.0)
    , current_x_accel(0.0)
    , target_x_accel(0.0)
    , lateral_en(false)
    , longitudinal_en(false)
    , lat(0.0)
    , lon(0.0)
    , yaw_angle(0.0)
    , utm_x(0.0)
    , utm_y(0.0)
    , utm_local_x(0.0)
    , utm_local_y(0.0)
    , hAcc(0.0)
    , vAcc(0.0)
    , data_tmp()  {
      data_tmp.assign(0.0);
  }
  vehicle_can_msg_(const ContainerAllocator& _alloc)
    : current_vehicle_speed(0)
    , Pure_Pursuit_angle__deg(0.0)
    , brake_pressure(0.0)
    , current_steer_angle__deg(0.0)
    , vehicle_target_speed__kph(0.0)
    , running_time_dead_reckoning_thread_running_time__ms(0.0)
    , running_time_pathfollow_thread_running_time__ms(0.0)
    , running_time_decision_thread_running_time__ms(0.0)
    , running_time_waypoint_publish_thread__ms(0.0)
    , running_time_local_path_planning_loop__ms(0.0)
    , running_time_global_path_planning_loop__ms(0.0)
    , dr_x(0.0)
    , dr_y(0.0)
    , dr_yaw_angle(0.0)
    , vehicle_yaw_rate(0.0)
    , dr_yaw_rate_integral_val(0.0)
    , elapsedTime(0.0)
    , target_accel(0.0)
    , target_brake_intensity(0.0)
    , target_steer_angle__deg(0.0)
    , h_acc(0.0)
    , v_acc(0.0)
    , yaw_acc(0.0)
    , imu_cali_yaw_angle(0.0)
    , imu_get_gnss_angle(0.0)
    , can_rw_thread_alive_count(0.0)
    , ccan_rw_thread_alive_count(0.0)
    , dn_lane_alive_count(0.0)
    , imu_vn300_alive_count(0.0)
    , lane_follow_enable_flag(0.0)
    , dr_check_flag(0.0)
    , avc_check_flag(0.0)
    , gnss_check_flag(0.0)
    , imu_yaw_angle_flag(0.0)
    , path_follow_check_flag(0.0)
    , ros_publisher_check_flag(0.0)
    , lateral_error(0.0)
    , current_x_accel(0.0)
    , target_x_accel(0.0)
    , lateral_en(false)
    , longitudinal_en(false)
    , lat(0.0)
    , lon(0.0)
    , yaw_angle(0.0)
    , utm_x(0.0)
    , utm_y(0.0)
    , utm_local_x(0.0)
    , utm_local_y(0.0)
    , hAcc(0.0)
    , vAcc(0.0)
    , data_tmp()  {
  (void)_alloc;
      data_tmp.assign(0.0);
  }



   typedef int32_t _current_vehicle_speed_type;
  _current_vehicle_speed_type current_vehicle_speed;

   typedef double _Pure_Pursuit_angle__deg_type;
  _Pure_Pursuit_angle__deg_type Pure_Pursuit_angle__deg;

   typedef double _brake_pressure_type;
  _brake_pressure_type brake_pressure;

   typedef double _current_steer_angle__deg_type;
  _current_steer_angle__deg_type current_steer_angle__deg;

   typedef double _vehicle_target_speed__kph_type;
  _vehicle_target_speed__kph_type vehicle_target_speed__kph;

   typedef double _running_time_dead_reckoning_thread_running_time__ms_type;
  _running_time_dead_reckoning_thread_running_time__ms_type running_time_dead_reckoning_thread_running_time__ms;

   typedef double _running_time_pathfollow_thread_running_time__ms_type;
  _running_time_pathfollow_thread_running_time__ms_type running_time_pathfollow_thread_running_time__ms;

   typedef double _running_time_decision_thread_running_time__ms_type;
  _running_time_decision_thread_running_time__ms_type running_time_decision_thread_running_time__ms;

   typedef double _running_time_waypoint_publish_thread__ms_type;
  _running_time_waypoint_publish_thread__ms_type running_time_waypoint_publish_thread__ms;

   typedef double _running_time_local_path_planning_loop__ms_type;
  _running_time_local_path_planning_loop__ms_type running_time_local_path_planning_loop__ms;

   typedef double _running_time_global_path_planning_loop__ms_type;
  _running_time_global_path_planning_loop__ms_type running_time_global_path_planning_loop__ms;

   typedef double _dr_x_type;
  _dr_x_type dr_x;

   typedef double _dr_y_type;
  _dr_y_type dr_y;

   typedef double _dr_yaw_angle_type;
  _dr_yaw_angle_type dr_yaw_angle;

   typedef double _vehicle_yaw_rate_type;
  _vehicle_yaw_rate_type vehicle_yaw_rate;

   typedef double _dr_yaw_rate_integral_val_type;
  _dr_yaw_rate_integral_val_type dr_yaw_rate_integral_val;

   typedef double _elapsedTime_type;
  _elapsedTime_type elapsedTime;

   typedef double _target_accel_type;
  _target_accel_type target_accel;

   typedef double _target_brake_intensity_type;
  _target_brake_intensity_type target_brake_intensity;

   typedef double _target_steer_angle__deg_type;
  _target_steer_angle__deg_type target_steer_angle__deg;

   typedef double _h_acc_type;
  _h_acc_type h_acc;

   typedef double _v_acc_type;
  _v_acc_type v_acc;

   typedef double _yaw_acc_type;
  _yaw_acc_type yaw_acc;

   typedef double _imu_cali_yaw_angle_type;
  _imu_cali_yaw_angle_type imu_cali_yaw_angle;

   typedef double _imu_get_gnss_angle_type;
  _imu_get_gnss_angle_type imu_get_gnss_angle;

   typedef double _can_rw_thread_alive_count_type;
  _can_rw_thread_alive_count_type can_rw_thread_alive_count;

   typedef double _ccan_rw_thread_alive_count_type;
  _ccan_rw_thread_alive_count_type ccan_rw_thread_alive_count;

   typedef double _dn_lane_alive_count_type;
  _dn_lane_alive_count_type dn_lane_alive_count;

   typedef double _imu_vn300_alive_count_type;
  _imu_vn300_alive_count_type imu_vn300_alive_count;

   typedef double _lane_follow_enable_flag_type;
  _lane_follow_enable_flag_type lane_follow_enable_flag;

   typedef double _dr_check_flag_type;
  _dr_check_flag_type dr_check_flag;

   typedef double _avc_check_flag_type;
  _avc_check_flag_type avc_check_flag;

   typedef double _gnss_check_flag_type;
  _gnss_check_flag_type gnss_check_flag;

   typedef double _imu_yaw_angle_flag_type;
  _imu_yaw_angle_flag_type imu_yaw_angle_flag;

   typedef double _path_follow_check_flag_type;
  _path_follow_check_flag_type path_follow_check_flag;

   typedef double _ros_publisher_check_flag_type;
  _ros_publisher_check_flag_type ros_publisher_check_flag;

   typedef double _lateral_error_type;
  _lateral_error_type lateral_error;

   typedef double _current_x_accel_type;
  _current_x_accel_type current_x_accel;

   typedef double _target_x_accel_type;
  _target_x_accel_type target_x_accel;

   typedef uint8_t _lateral_en_type;
  _lateral_en_type lateral_en;

   typedef uint8_t _longitudinal_en_type;
  _longitudinal_en_type longitudinal_en;

   typedef double _lat_type;
  _lat_type lat;

   typedef double _lon_type;
  _lon_type lon;

   typedef double _yaw_angle_type;
  _yaw_angle_type yaw_angle;

   typedef double _utm_x_type;
  _utm_x_type utm_x;

   typedef double _utm_y_type;
  _utm_y_type utm_y;

   typedef double _utm_local_x_type;
  _utm_local_x_type utm_local_x;

   typedef double _utm_local_y_type;
  _utm_local_y_type utm_local_y;

   typedef double _hAcc_type;
  _hAcc_type hAcc;

   typedef double _vAcc_type;
  _vAcc_type vAcc;

   typedef boost::array<double, 100>  _data_tmp_type;
  _data_tmp_type data_tmp;





  typedef boost::shared_ptr< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> const> ConstPtr;

}; // struct vehicle_can_msg_

typedef ::vehicle_can_msg_pkg::vehicle_can_msg_<std::allocator<void> > vehicle_can_msg;

typedef boost::shared_ptr< ::vehicle_can_msg_pkg::vehicle_can_msg > vehicle_can_msgPtr;
typedef boost::shared_ptr< ::vehicle_can_msg_pkg::vehicle_can_msg const> vehicle_can_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator1> & lhs, const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator2> & rhs)
{
  return lhs.current_vehicle_speed == rhs.current_vehicle_speed &&
    lhs.Pure_Pursuit_angle__deg == rhs.Pure_Pursuit_angle__deg &&
    lhs.brake_pressure == rhs.brake_pressure &&
    lhs.current_steer_angle__deg == rhs.current_steer_angle__deg &&
    lhs.vehicle_target_speed__kph == rhs.vehicle_target_speed__kph &&
    lhs.running_time_dead_reckoning_thread_running_time__ms == rhs.running_time_dead_reckoning_thread_running_time__ms &&
    lhs.running_time_pathfollow_thread_running_time__ms == rhs.running_time_pathfollow_thread_running_time__ms &&
    lhs.running_time_decision_thread_running_time__ms == rhs.running_time_decision_thread_running_time__ms &&
    lhs.running_time_waypoint_publish_thread__ms == rhs.running_time_waypoint_publish_thread__ms &&
    lhs.running_time_local_path_planning_loop__ms == rhs.running_time_local_path_planning_loop__ms &&
    lhs.running_time_global_path_planning_loop__ms == rhs.running_time_global_path_planning_loop__ms &&
    lhs.dr_x == rhs.dr_x &&
    lhs.dr_y == rhs.dr_y &&
    lhs.dr_yaw_angle == rhs.dr_yaw_angle &&
    lhs.vehicle_yaw_rate == rhs.vehicle_yaw_rate &&
    lhs.dr_yaw_rate_integral_val == rhs.dr_yaw_rate_integral_val &&
    lhs.elapsedTime == rhs.elapsedTime &&
    lhs.target_accel == rhs.target_accel &&
    lhs.target_brake_intensity == rhs.target_brake_intensity &&
    lhs.target_steer_angle__deg == rhs.target_steer_angle__deg &&
    lhs.h_acc == rhs.h_acc &&
    lhs.v_acc == rhs.v_acc &&
    lhs.yaw_acc == rhs.yaw_acc &&
    lhs.imu_cali_yaw_angle == rhs.imu_cali_yaw_angle &&
    lhs.imu_get_gnss_angle == rhs.imu_get_gnss_angle &&
    lhs.can_rw_thread_alive_count == rhs.can_rw_thread_alive_count &&
    lhs.ccan_rw_thread_alive_count == rhs.ccan_rw_thread_alive_count &&
    lhs.dn_lane_alive_count == rhs.dn_lane_alive_count &&
    lhs.imu_vn300_alive_count == rhs.imu_vn300_alive_count &&
    lhs.lane_follow_enable_flag == rhs.lane_follow_enable_flag &&
    lhs.dr_check_flag == rhs.dr_check_flag &&
    lhs.avc_check_flag == rhs.avc_check_flag &&
    lhs.gnss_check_flag == rhs.gnss_check_flag &&
    lhs.imu_yaw_angle_flag == rhs.imu_yaw_angle_flag &&
    lhs.path_follow_check_flag == rhs.path_follow_check_flag &&
    lhs.ros_publisher_check_flag == rhs.ros_publisher_check_flag &&
    lhs.lateral_error == rhs.lateral_error &&
    lhs.current_x_accel == rhs.current_x_accel &&
    lhs.target_x_accel == rhs.target_x_accel &&
    lhs.lateral_en == rhs.lateral_en &&
    lhs.longitudinal_en == rhs.longitudinal_en &&
    lhs.lat == rhs.lat &&
    lhs.lon == rhs.lon &&
    lhs.yaw_angle == rhs.yaw_angle &&
    lhs.utm_x == rhs.utm_x &&
    lhs.utm_y == rhs.utm_y &&
    lhs.utm_local_x == rhs.utm_local_x &&
    lhs.utm_local_y == rhs.utm_local_y &&
    lhs.hAcc == rhs.hAcc &&
    lhs.vAcc == rhs.vAcc &&
    lhs.data_tmp == rhs.data_tmp;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator1> & lhs, const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace vehicle_can_msg_pkg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3ed02c6ffe0085fc11beca26f35238db";
  }

  static const char* value(const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3ed02c6ffe0085fcULL;
  static const uint64_t static_value2 = 0x11beca26f35238dbULL;
};

template<class ContainerAllocator>
struct DataType< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "vehicle_can_msg_pkg/vehicle_can_msg";
  }

  static const char* value(const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 current_vehicle_speed\n"
"float64 Pure_Pursuit_angle__deg\n"
"float64 brake_pressure\n"
"float64 current_steer_angle__deg\n"
"float64 vehicle_target_speed__kph\n"
"float64 running_time_dead_reckoning_thread_running_time__ms\n"
"float64 running_time_pathfollow_thread_running_time__ms\n"
"float64 running_time_decision_thread_running_time__ms\n"
"float64 running_time_waypoint_publish_thread__ms\n"
"float64 running_time_local_path_planning_loop__ms\n"
"float64 running_time_global_path_planning_loop__ms\n"
"float64 dr_x\n"
"float64 dr_y\n"
"float64 dr_yaw_angle\n"
"float64 vehicle_yaw_rate\n"
"float64 dr_yaw_rate_integral_val\n"
"float64 elapsedTime\n"
"float64 target_accel\n"
"float64 target_brake_intensity \n"
"float64 target_steer_angle__deg\n"
"float64 h_acc\n"
"float64 v_acc\n"
"float64 yaw_acc\n"
"float64 imu_cali_yaw_angle\n"
"float64 imu_get_gnss_angle\n"
"float64 can_rw_thread_alive_count\n"
"float64 ccan_rw_thread_alive_count\n"
"float64 dn_lane_alive_count\n"
"float64 imu_vn300_alive_count\n"
"float64 lane_follow_enable_flag\n"
"float64 dr_check_flag\n"
"float64 avc_check_flag\n"
"float64 gnss_check_flag\n"
"float64 imu_yaw_angle_flag\n"
"float64 path_follow_check_flag\n"
"float64 ros_publisher_check_flag\n"
"float64 lateral_error\n"
"float64 current_x_accel\n"
"float64 target_x_accel\n"
"bool lateral_en\n"
"bool longitudinal_en\n"
"\n"
"float64 lat\n"
"float64 lon\n"
"float64 yaw_angle\n"
"float64 utm_x\n"
"float64 utm_y\n"
"float64 utm_local_x\n"
"float64 utm_local_y\n"
"float64 hAcc\n"
"float64 vAcc\n"
"\n"
"float64[100] data_tmp\n"
;
  }

  static const char* value(const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.current_vehicle_speed);
      stream.next(m.Pure_Pursuit_angle__deg);
      stream.next(m.brake_pressure);
      stream.next(m.current_steer_angle__deg);
      stream.next(m.vehicle_target_speed__kph);
      stream.next(m.running_time_dead_reckoning_thread_running_time__ms);
      stream.next(m.running_time_pathfollow_thread_running_time__ms);
      stream.next(m.running_time_decision_thread_running_time__ms);
      stream.next(m.running_time_waypoint_publish_thread__ms);
      stream.next(m.running_time_local_path_planning_loop__ms);
      stream.next(m.running_time_global_path_planning_loop__ms);
      stream.next(m.dr_x);
      stream.next(m.dr_y);
      stream.next(m.dr_yaw_angle);
      stream.next(m.vehicle_yaw_rate);
      stream.next(m.dr_yaw_rate_integral_val);
      stream.next(m.elapsedTime);
      stream.next(m.target_accel);
      stream.next(m.target_brake_intensity);
      stream.next(m.target_steer_angle__deg);
      stream.next(m.h_acc);
      stream.next(m.v_acc);
      stream.next(m.yaw_acc);
      stream.next(m.imu_cali_yaw_angle);
      stream.next(m.imu_get_gnss_angle);
      stream.next(m.can_rw_thread_alive_count);
      stream.next(m.ccan_rw_thread_alive_count);
      stream.next(m.dn_lane_alive_count);
      stream.next(m.imu_vn300_alive_count);
      stream.next(m.lane_follow_enable_flag);
      stream.next(m.dr_check_flag);
      stream.next(m.avc_check_flag);
      stream.next(m.gnss_check_flag);
      stream.next(m.imu_yaw_angle_flag);
      stream.next(m.path_follow_check_flag);
      stream.next(m.ros_publisher_check_flag);
      stream.next(m.lateral_error);
      stream.next(m.current_x_accel);
      stream.next(m.target_x_accel);
      stream.next(m.lateral_en);
      stream.next(m.longitudinal_en);
      stream.next(m.lat);
      stream.next(m.lon);
      stream.next(m.yaw_angle);
      stream.next(m.utm_x);
      stream.next(m.utm_y);
      stream.next(m.utm_local_x);
      stream.next(m.utm_local_y);
      stream.next(m.hAcc);
      stream.next(m.vAcc);
      stream.next(m.data_tmp);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct vehicle_can_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::vehicle_can_msg_pkg::vehicle_can_msg_<ContainerAllocator>& v)
  {
    s << indent << "current_vehicle_speed: ";
    Printer<int32_t>::stream(s, indent + "  ", v.current_vehicle_speed);
    s << indent << "Pure_Pursuit_angle__deg: ";
    Printer<double>::stream(s, indent + "  ", v.Pure_Pursuit_angle__deg);
    s << indent << "brake_pressure: ";
    Printer<double>::stream(s, indent + "  ", v.brake_pressure);
    s << indent << "current_steer_angle__deg: ";
    Printer<double>::stream(s, indent + "  ", v.current_steer_angle__deg);
    s << indent << "vehicle_target_speed__kph: ";
    Printer<double>::stream(s, indent + "  ", v.vehicle_target_speed__kph);
    s << indent << "running_time_dead_reckoning_thread_running_time__ms: ";
    Printer<double>::stream(s, indent + "  ", v.running_time_dead_reckoning_thread_running_time__ms);
    s << indent << "running_time_pathfollow_thread_running_time__ms: ";
    Printer<double>::stream(s, indent + "  ", v.running_time_pathfollow_thread_running_time__ms);
    s << indent << "running_time_decision_thread_running_time__ms: ";
    Printer<double>::stream(s, indent + "  ", v.running_time_decision_thread_running_time__ms);
    s << indent << "running_time_waypoint_publish_thread__ms: ";
    Printer<double>::stream(s, indent + "  ", v.running_time_waypoint_publish_thread__ms);
    s << indent << "running_time_local_path_planning_loop__ms: ";
    Printer<double>::stream(s, indent + "  ", v.running_time_local_path_planning_loop__ms);
    s << indent << "running_time_global_path_planning_loop__ms: ";
    Printer<double>::stream(s, indent + "  ", v.running_time_global_path_planning_loop__ms);
    s << indent << "dr_x: ";
    Printer<double>::stream(s, indent + "  ", v.dr_x);
    s << indent << "dr_y: ";
    Printer<double>::stream(s, indent + "  ", v.dr_y);
    s << indent << "dr_yaw_angle: ";
    Printer<double>::stream(s, indent + "  ", v.dr_yaw_angle);
    s << indent << "vehicle_yaw_rate: ";
    Printer<double>::stream(s, indent + "  ", v.vehicle_yaw_rate);
    s << indent << "dr_yaw_rate_integral_val: ";
    Printer<double>::stream(s, indent + "  ", v.dr_yaw_rate_integral_val);
    s << indent << "elapsedTime: ";
    Printer<double>::stream(s, indent + "  ", v.elapsedTime);
    s << indent << "target_accel: ";
    Printer<double>::stream(s, indent + "  ", v.target_accel);
    s << indent << "target_brake_intensity: ";
    Printer<double>::stream(s, indent + "  ", v.target_brake_intensity);
    s << indent << "target_steer_angle__deg: ";
    Printer<double>::stream(s, indent + "  ", v.target_steer_angle__deg);
    s << indent << "h_acc: ";
    Printer<double>::stream(s, indent + "  ", v.h_acc);
    s << indent << "v_acc: ";
    Printer<double>::stream(s, indent + "  ", v.v_acc);
    s << indent << "yaw_acc: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_acc);
    s << indent << "imu_cali_yaw_angle: ";
    Printer<double>::stream(s, indent + "  ", v.imu_cali_yaw_angle);
    s << indent << "imu_get_gnss_angle: ";
    Printer<double>::stream(s, indent + "  ", v.imu_get_gnss_angle);
    s << indent << "can_rw_thread_alive_count: ";
    Printer<double>::stream(s, indent + "  ", v.can_rw_thread_alive_count);
    s << indent << "ccan_rw_thread_alive_count: ";
    Printer<double>::stream(s, indent + "  ", v.ccan_rw_thread_alive_count);
    s << indent << "dn_lane_alive_count: ";
    Printer<double>::stream(s, indent + "  ", v.dn_lane_alive_count);
    s << indent << "imu_vn300_alive_count: ";
    Printer<double>::stream(s, indent + "  ", v.imu_vn300_alive_count);
    s << indent << "lane_follow_enable_flag: ";
    Printer<double>::stream(s, indent + "  ", v.lane_follow_enable_flag);
    s << indent << "dr_check_flag: ";
    Printer<double>::stream(s, indent + "  ", v.dr_check_flag);
    s << indent << "avc_check_flag: ";
    Printer<double>::stream(s, indent + "  ", v.avc_check_flag);
    s << indent << "gnss_check_flag: ";
    Printer<double>::stream(s, indent + "  ", v.gnss_check_flag);
    s << indent << "imu_yaw_angle_flag: ";
    Printer<double>::stream(s, indent + "  ", v.imu_yaw_angle_flag);
    s << indent << "path_follow_check_flag: ";
    Printer<double>::stream(s, indent + "  ", v.path_follow_check_flag);
    s << indent << "ros_publisher_check_flag: ";
    Printer<double>::stream(s, indent + "  ", v.ros_publisher_check_flag);
    s << indent << "lateral_error: ";
    Printer<double>::stream(s, indent + "  ", v.lateral_error);
    s << indent << "current_x_accel: ";
    Printer<double>::stream(s, indent + "  ", v.current_x_accel);
    s << indent << "target_x_accel: ";
    Printer<double>::stream(s, indent + "  ", v.target_x_accel);
    s << indent << "lateral_en: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lateral_en);
    s << indent << "longitudinal_en: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.longitudinal_en);
    s << indent << "lat: ";
    Printer<double>::stream(s, indent + "  ", v.lat);
    s << indent << "lon: ";
    Printer<double>::stream(s, indent + "  ", v.lon);
    s << indent << "yaw_angle: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_angle);
    s << indent << "utm_x: ";
    Printer<double>::stream(s, indent + "  ", v.utm_x);
    s << indent << "utm_y: ";
    Printer<double>::stream(s, indent + "  ", v.utm_y);
    s << indent << "utm_local_x: ";
    Printer<double>::stream(s, indent + "  ", v.utm_local_x);
    s << indent << "utm_local_y: ";
    Printer<double>::stream(s, indent + "  ", v.utm_local_y);
    s << indent << "hAcc: ";
    Printer<double>::stream(s, indent + "  ", v.hAcc);
    s << indent << "vAcc: ";
    Printer<double>::stream(s, indent + "  ", v.vAcc);
    s << indent << "data_tmp[]" << std::endl;
    for (size_t i = 0; i < v.data_tmp.size(); ++i)
    {
      s << indent << "  data_tmp[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.data_tmp[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // VEHICLE_CAN_MSG_PKG_MESSAGE_VEHICLE_CAN_MSG_H
